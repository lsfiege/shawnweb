#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Generate a C++ header which assigns the current SHA1 to a variable

# Bjoern Hendriks 2010, 2011, hendriks@ibr.cs.tu-bs.de

# Remark: The generated header only works for C++ and not for C as
#         constants have by default internal linkage in C++ as opposed
#         to C.

import sys
import os
from optparse import OptionParser
import string
import subprocess
import getCurrentRevision

# parse command line
optParser = OptionParser(usage="%prog [options] <header> [<variable> [<namespace>]]",
                         description="Generate a C++ header which assigns the current SHA1 to a variable.")
optParser.add_option("-r", "--reset", dest="reset", action="store_true", default=False,
                     help="reset header to last committed version before finding out current revision")
(options, args) = optParser.parse_args()

# check for presence of mandatory parameters
if len(args) < 1:
    sys.exit("ERROR: header name missing")

# get header name
header = args[0]
# append '.h' if necessary
if header.find('.') < 0:
    header = header + '.h'
# if header is an absolute path with symlinks git checkout will fail, so, resolve symlinks
header = os.path.realpath(header)

# get variable name if passed
variable = 'revision'
if len(args) >= 2:
    variable = args[1]
# get namespace name if passed
isNamespace = False
if len(args) >= 3:
    isNamespace = True
    namespace = args[2]

# construct include guard out of header name
guard = header.replace('.', '_')        # substitute '.' -> '_'
guard = guard.replace('/', '_')         # substitute '/' -> '_'
guard = guard.lstrip('_')               # remove leading '_'
guard = guard.upper()                   # convert to upper case

# get name of this script for comment
scriptname = os.path.basename(sys.argv[0])

# get revision
(revision, getResult) = getCurrentRevision.getRevision()
# is reset set and workfiles dirty?
if options.reset and (getResult == getCurrentRevision.resultDirty):
    # remove header from index
    subprocess.call(args=["git", "reset", header], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # get last committed version of header
    subprocess.call(args=["git", "checkout", header], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # update revision string
    revision = getCurrentRevision.getRevision()[0]  # only get revision, not result code

# make namespace code
if isNamespace:
    beginNamespace = 'namespace ' + namespace + '\n{'
    endNamespace   = '}   // namespace ' + namespace + '\n'
else:
    beginNamespace = ''
    endNamespace   = ''

# template for header file
headerTemplate = string.Template("""
/**********************************************************************

        Header generated by ${scriptname}, DO NOT EDIT

**********************************************************************/

#ifndef ${guard}
#define ${guard}

#include <string>

${beginNamespace}

const std::string ${variable} = "${revision}";

${endNamespace}

#endif  // #ifndef ${guard}

""")

# do substitutions
output = headerTemplate.substitute(scriptname=scriptname, guard=guard, beginNamespace=beginNamespace, variable=variable, revision=revision, endNamespace=endNamespace)

# write header file
headerFile = open(header, 'w')
headerFile.write(output)
headerFile.close()


